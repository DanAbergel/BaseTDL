<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Main</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-slider-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-image-slider-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-likert@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-fullscreen@1.2.1"></script>
    <script src="https://unpkg.com/@jspsych/plugin-instructions@1.1.3"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" type="text/css">

    <script src="libs/jquery-3.5.1.min.js"></script>
    <script src="jatos.js"></script>
    <script src="utils.js"></script>
    <script src="trials.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
    <script src="bot_funcs.js"></script>
    <script src="bot.js"></script>
    <link rel="stylesheet" href="libs/pure-release-0.6.0/pure-min.css">
    <link rel="stylesheet" type="text/css" href="css/styles.css" />


    <script id="Variables">
        const jsPsych = initJsPsych() ;
        let showLog = false;

        // BOT Variables
        let botActive = false;
        let associationsPerBreak = 0;
        let words_list = [];
        let textInput_limit = 0;
        let textStart_limit = 0;
        let breakStates = []
        let assocIndex = 0;
        let enteredWord = ""; // Initialize the entered word
        let bots = [];
    </script>

    <script id="Synchronous_helpers">
        /*******************************************************
         * CHECK BREAK CONDITION BETWEEN ASSOCIATIONS
         * -----------------------------------------------------
         * We trigger a break when:
         *  - The number of associations so far (`assocIndex`)
         *    is a multiple of `associationsPerBreak`
         *  - The last sender is still active (not a leaver)
         *******************************************************/
        function checkBreak() {
            return assocIndex % associationsPerBreak === 0;
        }



        function getQuestionsTrial() {
            /*******************************************************
            * QUESTIONNAIRE TRIALS BETWEEN ASSOCIATIONS
            * -----------------------------------------------------
            * Presents a short set of Likert-scale questions to the
            * participant. These questions assess:
            *   - Enjoyment of the game
            *   - Feeling of synchrony with each other participant
            *   - Likeability of each other participant
            *
            * The questions involving other players dynamically
            * display the other players' avatars, based on shuffled
            * ordering of participant IDs.
            *******************************************************/
            let questions = [];
            const ids = shuffle_seed(getAllPlayersIds(true));
            const base = (text, id) =>
                function () {
                    const centerHtml =
                        text +
                        " <img src='" +
                        getRandomAvatarById(id) +
                        "' style='width: 50px; height: 50px;'>";

                    return getScreen({
                        center: [centerHtml],
                        hideOthers: true
                    });
            };
            questions.push(
                createLikertTrial("To what extent do you identify with the following statement:<br><b>I enjoy the game so far</b>", "enjoy")
            );
            ids.forEach(id =>
                questions.push(
                    createLikertTrial(
                        base("To what extent do you identify with the following statement:<br><b>I feel in-sync with</b>", id),
                        "sync_" + id)
                )
            );
            ids.forEach(id =>
                questions.push(
                    createLikertTrial(base("To what extent do you identify with the following statement:<br><b>So far, I like</b>", id),
                        "like_" + id)
                )
            );
            return questions;
        }

        /**
         * SYNC PLAYERS TRIAL
         * ---------------------------------------------------------
         * This function creates a synchronization point after each
         * word association. It:
         *   1. Displays the target word and the current player's
         *      submitted response (readâ€‘only).
         *   2. Waits until *all* players have written their value
         *      to groupSession under the key "<playerId>_<word>".
         *   3. Uses getAllFinishParamTrial to block progression
         *      until every participant has finished this step.
         *
         * In short: this is a synchronization barrier that ensures
         * everyone has answered before moving on to the next trial.
         */
        function syncPlayers(word) {
            const stimulus = () => {
                // --- Other players ---
                const others = getAllOtherPlayersIds();

                // Everyone else is "loading"
                const loading = others.map(() => true);

                // No words displayed under other players here
                const assocs = others.map(() => "");

                // --- Center content ---
                const stimulusDiv = getHtmlTag(
                    "div",
                    "stimuli_word",
                    "stimuli_word",
                    word
                );

                const myValue =
                    jatos.groupSession.get(jatos.groupMemberId + "_" + word) || "";

                const myInput = getHtmlTag(
                    "input",
                    "word_input",
                    null,
                    null,
                    { value: myValue, disabled: true }
                );

                return getScreen({
                    center: [stimulusDiv, myInput],
                    hideOthers: false,
                    others,
                    loading,
                    assocs
                });
            };

            return getAllFinishParamTrial(
                "_" + word,
                "",
                "*",
                true,
                600,
                stimulus
            );
        }
    </script>

    <script id="Helpers">
        async function initializeSessionVariables() {
            // Wait for bot data to be loaded
            await botDataReady;
            // Load configuration data from JATOS, using batch-level settings by default, falling back to empty object if none provided
            const cfg_batch = jatos.batchJsonInput || {};
            const cfg_study = jatos.studyJsonInput || {};
            // Enable or disable detailed logging in the console (default: false)
            showLog = cfg_batch.showLog || cfg_study.showLog || false;
            associationsPerBreak = cfg_batch.associationsPerBreak || cfg_study.associationsPerBreak || 10;
            // Whether a bot should answer for absent players (default: false)
            botActive = cfg_batch.botActive || cfg_study.botActive || false;
            console.log("botActive", botActive);
            // Duration of the break between blocks (default: 15 seconds)
            break_duration = cfg_batch.break_duration || cfg_study.break_duration || 15 * 1000
            console.log(MAIN_WORDS_PROPERTY,jatos.groupSession.getAll());
            words_list = jatos.groupSession.get(MAIN_WORDS_PROPERTY);
            console.log("words list = ",words_list);
            textInput_limit = jatos.batchJsonInput.textInput_limit || jatos.studyJsonInput.textInput_limit || 10
            textStart_limit = jatos.batchJsonInput.textStart_limit || jatos.studyJsonInput.textStart_limit || 1.5
            for(const id of getAllPlayersIds()) {
                bots.push([id,new Bot(id)]);
            }
            console.log("[BOT SYSTEM] Bot players (created at start or replacing leaved): ", getBotPlayersIds());
            console.log("[BOT SYSTEM] Total players: ", getAllPlayersIds());
            console.log("[BOT SYSTEM] Present human players: ", getPresentPlayersIds());
            // ==========================================================
            // Structured debug logs
            // ==========================================================
            if (showLog) {
                console.groupCollapsed("%c[INITIALIZATION SUMMARY]", "color: #2e86de; font-weight: bold;");
                console.table({
                    "AssociationsPerBreak": associationsPerBreak,
                    "Break duration": break_duration,
                    "Bot active": botActive,
                    "Words list": words_list ? words_list.join(", ") : "None",
                });
                console.groupEnd();
            }
        }

        function updateAssociationState(word) {
            return {
                type: jsPsychCallFunction,
                func: () => {
                    assocIndex += 1;
                    enteredWord = "";
                }
            }
        }

        function updateGD_trial(word){
            return updateGroupSessionTrial(
                [[jatos.groupMemberId + '_' + word,
                () => {
                    console.log("entered word = ",enteredWord);
                    return enteredWord ? enteredWord : NO_RESPONSE;}
                ]]
            );
        }

        // Handles bot responses - both bots created at initialization and bots replacing leaved players
        function updateGD_leavedPlayers(word) {
            let updateBots_trial =  {
                type:jsPsychCallFunction,
                func: () => {
                    let key_values = [];
                    const botsPlayers = [...getBotPlayersIds(), ...getLeavedPlayersIds()];

                    console.log(`[BOT SYSTEM] Processing ${botsPlayers.length} bot(s) for word: "${word}"`);

                    if (botsPlayers.length === 0) {
                        console.log("[BOT SYSTEM] No bots to process");
                        return;
                    }

                    for (let i = 0; i < botsPlayers.length; i++) {
                        const player = botsPlayers[i];
                        const key = player + "_" + word;

                        // Get bot instance
                        const bot = getBotByPlayerId(player);
                        if (!bot) {
                            console.error(`[BOT SYSTEM] Bot instance not found for player: ${player}`);
                            continue;
                        }

                        // Get bot response with new format { association, rt, debugInfo }
                        const botResponse = bot.getAssocWord(word);
                        const { association, rt, debugInfo } = botResponse;

                        // Log bot reasoning
                        console.log(`[BOT ${player}] =====================`);
                        console.log(`[BOT ${player}] Cue: "${word}"`);
                        console.log(`[BOT ${player}] Response: "${association}" (RT: ${rt}ms)`);
                        if (debugInfo) {
                            console.log(`[BOT ${player}] Cue in dictionary: ${debugInfo.cueInDictionary}`);
                            console.log(`[BOT ${player}] Source: ${debugInfo.finalCueSource}`);
                            if (debugInfo.finalUsedCue !== word.toLowerCase()) {
                                console.log(`[BOT ${player}] Used cue instead: "${debugInfo.finalUsedCue}"`);
                            }
                            console.log(`[BOT ${player}] Iterations: ${debugInfo.iterations}`);
                            if (debugInfo.track_assoc && debugInfo.track_assoc.length > 1) {
                                console.log(`[BOT ${player}] Rejected associations: ${debugInfo.track_assoc.slice(0, -1).join(', ')}`);
                            }
                        }

                        key_values.push([key, association]);
                    }

                    if (key_values.length > 0) {
                        console.log(`[BOT SYSTEM] Storing ${key_values.length} bot response(s)`);
                        updateGroupSessionRobust(key_values);
                    }
                }
            }
            return makeConditionalTrial(iAmManager, [updateBots_trial]);
        }
    </script>
    <script id="Experiment">
        async function onOpen(){
            await initializeSessionVariables();
            let timeline = [];
            // timeline.push(...manageFullScreenTrial());
            words_list.forEach(word => {
                timeline.push(updateAssociationState(word));
                timeline.push(getCountdownTrial(word));
                timeline.push(getWordExchangeTrial(word));
                timeline.push(updateGD_trial(word));
                timeline.push(updateGD_leavedPlayers(word));
                timeline.push(syncPlayers(word));
                timeline.push(getDisplayAnswersTrial(word));
                timeline.push(break_condition());
            });

            jsPsych.run(timeline);

            // Add metadata to the jsPsych dataset
            jsPsych.data.addProperties({
                groupAllocation: jatos.groupSession.get(ALLOCATED_GROUP_PROPERTY),
                ProlificID: jatos.urlQueryParameters.PROLIFIC_PID,
                ProlificStudyID: jatos.urlQueryParameters.STUDY_ID,
                ProlificSessionID: jatos.urlQueryParameters.SESSION_ID
            });
        }
        function onClose(){}
        function onMemberOpen(id){}
        function onMemberClose(id){}
        function onMemberLeave(id){}
        function onGroupSession(path,op){}
        function printError(message){}

        jatos.onLoad(
            function () {
                jatos.joinGroup({
                    "onOpen": onOpen,
                    "onClose": onClose,
                    "onGroupSession": onGroupSession,
                    "onMemberOpen": onMemberOpen,
                    "onMemberClose": onMemberClose,
                    "onMemberLeave": onMemberLeave,
                    "onError": printError,
                });
          });
    </script>
</head>
</html>